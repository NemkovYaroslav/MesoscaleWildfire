#pragma kernel kernel_init
#pragma kernel kernel_user_input
#pragma kernel kernel_read_data
#pragma kernel kernel_modules_influence
#pragma kernel kernel_diffusion

RWTexture3D<float4> ColorTemperatureTexture;
RWTexture3D<float4> TexelTemperatureTexture;

float3 texture_resolution;
float3 torch_position;

float source_intensity;
float diffusion_intensity;
float delta_time;

int modules_number;

Texture3D myTexture3D;
SamplerState linearClampSampler;

RWStructuredBuffer<float4> posTempBuffer;

RWStructuredBuffer<float4> PositionTemperatureBuffer;

#define TOP_OFFSET    int3( 0, 1, 0)
#define BOTTOM_OFFSET int3( 0,-1, 0)
#define RIGHT_OFFSET  int3( 1, 0, 0)
#define LEFT_OFFSET   int3(-1, 0, 0)
#define FRONT_OFFSET  int3( 0, 0, 1)
#define BACK_OFFSET   int3( 0, 0,-1)

int get_obstacle(const int3 id)
{
    int obstacle = 1;
    
    const float3 padding = 1;
    const float3 volume_size = texture_resolution - padding * 2;
    if (id.x < padding.x || id.y < padding.y || id.z < padding.z
            || id.x > volume_size.x || id.y > volume_size.y || id.z > volume_size.z)
    {
        obstacle = 0;
    }
    
    return obstacle;
}

[numthreads(8,8,8)]
void kernel_init (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;
    
    ColorTemperatureTexture[pixel_id] = 0;
    TexelTemperatureTexture[pixel_id] = 0;
}

[numthreads(1,1,1)]
void kernel_user_input (uint3 id : SV_DispatchThreadID)
{
    if (source_intensity > 0)
    {
        float3 uv = torch_position;
        uv += 0.5f;
        uv *= texture_resolution;

        const float3 nearest_cell_uv = uv - 0.5f;
        const float3 floor_cell_uv = floor(nearest_cell_uv);
        
        const float3 cell_000 = floor_cell_uv;
        const float3 cell_100 = floor_cell_uv + float3(1, 0, 0);
        const float3 cell_010 = floor_cell_uv + float3(0, 1, 0);
        const float3 cell_001 = floor_cell_uv + float3(0, 0, 1);
        const float3 cell_110 = floor_cell_uv + float3(1, 1, 0);
        const float3 cell_101 = floor_cell_uv + float3(1, 0, 1);
        const float3 cell_011 = floor_cell_uv + float3(0, 1, 1);
        const float3 cell_111 = floor_cell_uv + float3(1, 1, 1);
        

        const float x_1 = nearest_cell_uv.x - floor_cell_uv.x;
        const float x_0 = 1.0f - x_1;

        const float y_1 = nearest_cell_uv.y - floor_cell_uv.y;
        const float y_0 = 1.0f - y_1;

        const float z_1 = nearest_cell_uv.z - floor_cell_uv.z;
        const float z_0 = 1.0f - z_1;

        const float inf_000 = x_0 * y_0 * z_0;
        const float inf_100 = x_1 * y_0 * z_0;
        const float inf_010 = x_0 * y_1 * z_0;
        const float inf_001 = x_0 * y_0 * z_1;
        const float inf_110 = x_1 * y_1 * z_0;
        const float inf_101 = x_1 * y_0 * z_1;
        const float inf_011 = x_0 * y_1 * z_1;
        const float inf_111 = x_1 * y_1 * z_1;
        
        
        const float3 color = float3(1, 1, 0);
        
        float temperature = 0.0f;
        //const float temperature = source_intensity * delta_time;
        
        float4 temperature_cell_000 = ColorTemperatureTexture[cell_000];
        temperature_cell_000.rgb = color;
        temperature = source_intensity * inf_000;
        temperature_cell_000.a = clamp(temperature_cell_000.a + temperature, 0.0f, 1.0f);
        ColorTemperatureTexture[cell_000] = temperature_cell_000;
        TexelTemperatureTexture[cell_000] = float4(0, 0, 0, temperature_cell_000.a);

        float4 temperature_cell_100 = ColorTemperatureTexture[cell_100];
        temperature_cell_100.rgb = color;
        temperature = source_intensity * inf_100;
        temperature_cell_100.a = clamp(temperature_cell_100.a + temperature, 0.0f, 1.0f);
        ColorTemperatureTexture[cell_100] = temperature_cell_100;
        TexelTemperatureTexture[cell_100] = float4(0, 0, 0, temperature_cell_100.a);

        float4 temperature_cell_010 = ColorTemperatureTexture[cell_010];
        temperature_cell_010.rgb = color;
        temperature = source_intensity * inf_010;
        temperature_cell_010.a = clamp(temperature_cell_010.a + temperature, 0.0f, 1.0f);
        ColorTemperatureTexture[cell_010] = temperature_cell_010;
        TexelTemperatureTexture[cell_010] = float4(0, 0, 0, temperature_cell_010.a);

        float4 temperature_cell_001 = ColorTemperatureTexture[cell_001];
        temperature_cell_001.rgb = color;
        temperature = source_intensity * inf_001;
        temperature_cell_001.a = clamp(temperature_cell_001.a + temperature, 0.0f, 1.0f);
        ColorTemperatureTexture[cell_001] = temperature_cell_001;
        TexelTemperatureTexture[cell_001] = float4(0, 0, 0, temperature_cell_001.a);

        float4 temperature_cell_110 = ColorTemperatureTexture[cell_110];
        temperature_cell_110.rgb = color;
        temperature = source_intensity * inf_110;
        temperature_cell_110.a = clamp(temperature_cell_110.a + temperature, 0.0f, 1.0f);
        ColorTemperatureTexture[cell_110] = temperature_cell_110;
        TexelTemperatureTexture[cell_110] = float4(0, 0, 0, temperature_cell_110.a);

        float4 temperature_cell_101 = ColorTemperatureTexture[cell_101];
        temperature_cell_101.rgb = color;
        temperature = source_intensity * inf_101;
        temperature_cell_101.a = clamp(temperature_cell_101.a + temperature, 0.0f, 1.0f);
        ColorTemperatureTexture[cell_101] = temperature_cell_101;
        TexelTemperatureTexture[cell_101] = float4(0, 0, 0, temperature_cell_101.a);

        float4 temperature_cell_011 = ColorTemperatureTexture[cell_011];
        temperature_cell_011.rgb = color;
        temperature = source_intensity * inf_011;
        temperature_cell_011.a = clamp(temperature_cell_011.a + temperature, 0.0f, 1.0f);
        ColorTemperatureTexture[cell_011] = temperature_cell_011;
        TexelTemperatureTexture[cell_011] = float4(0, 0, 0, temperature_cell_011.a);

        float4 temperature_cell_111 = ColorTemperatureTexture[cell_111];
        temperature_cell_111.rgb = color;
        temperature = source_intensity * inf_111;
        temperature_cell_111.a = clamp(temperature_cell_111.a + temperature, 0.0f, 1.0f);
        ColorTemperatureTexture[cell_111] = temperature_cell_111;
        TexelTemperatureTexture[cell_111] = float4(0, 0, 0, temperature_cell_111.a);
    }
}

[numthreads(1,1,1)]
void kernel_read_data (uint3 id : SV_DispatchThreadID)
{
    const int index = id.x;
    
    // sample temperature data from texture
    float3 u_v = posTempBuffer[index].xyz;
    u_v += 0.5f;
    float4 val = myTexture3D.SampleLevel(linearClampSampler, u_v, 0);
    posTempBuffer[index].w = val.w;
    
    // calculate texture position
    u_v *= texture_resolution;
    u_v -= 0.5f;
    posTempBuffer[index].xyz = u_v;
}

[numthreads(8,8,8)]
void kernel_modules_influence (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;
    
    const int obstacle_value = get_obstacle(pixel_id);
    
    if (obstacle_value)
    {
        for (int i = 0; i < modules_number; i++)
        {
            float3 position = PositionTemperatureBuffer[i].xyz;
            
            position += 0.5f;
            position *= texture_resolution;
            position -= 0.5f;
            
            const float dist = distance(position, pixel_id);
            if (dist < 1)
            {
                float4 color_temperature_value = ColorTemperatureTexture[pixel_id];

                color_temperature_value.rgb = float3(1, 1, 0);
                
                const float temperature = PositionTemperatureBuffer[i].a;

                //const float factor = 1 - dist;
                const float delta = temperature * 0.125f;
                color_temperature_value.a = clamp(color_temperature_value.a + delta, 0, 1);
                
                ColorTemperatureTexture[pixel_id] = color_temperature_value;

                TexelTemperatureTexture[pixel_id] = float4(pixel_id.x, pixel_id.y, pixel_id.z, color_temperature_value.a);
            }
        }
    }
}

[numthreads(8,8,8)]
void kernel_diffusion (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;
    
    const int3 top_pixel_id    = pixel_id + TOP_OFFSET;
    const int3 bottom_pixel_id = pixel_id + BOTTOM_OFFSET;
    const int3 right_pixel_id  = pixel_id + RIGHT_OFFSET;
    const int3 left_pixel_id   = pixel_id + LEFT_OFFSET;
    const int3 front_pixel_id  = pixel_id + FRONT_OFFSET;
    const int3 back_pixel_id   = pixel_id + BACK_OFFSET;

    const float obstacle_value = get_obstacle(pixel_id);
    
    if (obstacle_value)
    {
        const float top_obstacle_value    = get_obstacle(top_pixel_id);
        const float bottom_obstacle_value = get_obstacle(bottom_pixel_id);
        const float right_obstacle_value  = get_obstacle(right_pixel_id);
        const float left_obstacle_value   = get_obstacle(left_pixel_id);
        const float front_obstacle_value  = get_obstacle(front_pixel_id);
        const float back_obstacle_value   = get_obstacle(back_pixel_id);
    
        const float4 density_value        = ColorTemperatureTexture[pixel_id];
        const float4 top_density_value    = ColorTemperatureTexture[top_pixel_id]    * top_obstacle_value;
        const float4 bottom_density_value = ColorTemperatureTexture[bottom_pixel_id] * bottom_obstacle_value;
        const float4 right_density_value  = ColorTemperatureTexture[right_pixel_id]  * right_obstacle_value;
        const float4 left_density_value   = ColorTemperatureTexture[left_pixel_id]   * left_obstacle_value;
        const float4 front_density_value  = ColorTemperatureTexture[front_pixel_id]  * front_obstacle_value;
        const float4 back_density_value   = ColorTemperatureTexture[back_pixel_id]   * back_obstacle_value;
    
        const float k = delta_time * diffusion_intensity * texture_resolution.x;
        float4 new_density_value =
            (
                density_value
                + k
                * (top_density_value + bottom_density_value + right_density_value + left_density_value + front_density_value + back_density_value)
            )
            / (1 + 6.0 * k);
        
        ColorTemperatureTexture[pixel_id] = new_density_value;
    
        TexelTemperatureTexture[pixel_id] = float4(pixel_id.x, pixel_id.y, pixel_id.z, new_density_value.a);
    }
}