#pragma kernel kernel_init
#pragma kernel kernel_user_input
#pragma kernel kernel_modules_influence
#pragma kernel kernel_diffusion

#pragma kernel kernel_read_texture

RWTexture3D<float4> color_temperature_texture;
RWTexture3D<float4> texel_temperature_texture;

float3 texture_resolution;
float3 torch_position;

float source_intensity;
float diffusion_intensity;
float delta_time;

int modules_number;

Texture3D MyTex;
SamplerState MyLinearClampSampler;

RWStructuredBuffer<float4> position_temperature_buffer;

#define TOP_OFFSET    int3( 0, 1, 0)
#define BOTTOM_OFFSET int3( 0,-1, 0)
#define RIGHT_OFFSET  int3( 1, 0, 0)
#define LEFT_OFFSET   int3(-1, 0, 0)
#define FRONT_OFFSET  int3( 0, 0, 1)
#define BACK_OFFSET   int3( 0, 0,-1)

int get_obstacle(const int3 id)
{
    int obstacle = 1;
    
    const float3 padding = 1;
    const float3 volume_size = texture_resolution - padding * 2;
    if (id.x < padding.x || id.y < padding.y || id.z < padding.z
            || id.x > volume_size.x || id.y > volume_size.y || id.z > volume_size.z)
    {
        obstacle = 0;
    }
    
    return obstacle;
}

[numthreads(8,8,8)]
void kernel_init (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;
    
    color_temperature_texture[pixel_id] = 0;
    texel_temperature_texture[pixel_id] = 0;
}

[numthreads(1,1,1)]
void kernel_read_texture (uint3 id : SV_DispatchThreadID)
{
    
}

[numthreads(8,8,8)]
void kernel_user_input (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;
    
    if (source_intensity > 0)
    {
        float3 torch_u_v = torch_position;
        torch_u_v += 0.5f;
        torch_u_v *= texture_resolution;
        torch_u_v -= 0.5f;

        const float dist = distance(torch_u_v, pixel_id);
        if (dist < 1)
        {
            float4 density_value = color_temperature_texture[pixel_id];

            density_value.rgb = float3(1, 1, 0);
        
            const float factor = 1 - dist;
            const float delta = source_intensity * factor;
            density_value.a = clamp(density_value.a + delta, 0, 1);

            color_temperature_texture[pixel_id] = density_value;
    
            texel_temperature_texture[pixel_id] = float4(pixel_id.x, pixel_id.y, pixel_id.z, density_value.a);
        }
    }
    
    /*
    const int obstacle_value = get_obstacle(pixel_id);
    if (obstacle_value)
    {
        if (source_intensity > 0)
        {
            float3 torch_u_v = torch_position;
            torch_u_v += 0.5f;
            torch_u_v *= texture_resolution;
            torch_u_v -= 0.5f;

            const float dist = distance(torch_u_v, pixel_id);
            if (dist < 1)
            {
                float4 density_value = color_temperature_texture[pixel_id];

                density_value.rgb = float3(1, 1, 0);
            
                const float factor = 1 - dist;
                const float delta = source_intensity * factor;
                density_value.a = clamp(density_value.a + delta, 0, 1);

                color_temperature_texture[pixel_id] = density_value;
        
                texel_temperature_texture[pixel_id] = float4(pixel_id.x, pixel_id.y, pixel_id.z, density_value.a);
            }
        }
    }
    */
}

[numthreads(8,8,8)]
void kernel_modules_influence (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;

    const int obstacle_value = get_obstacle(pixel_id);
    
    if (obstacle_value)
    {
        for (int i = 0; i < modules_number; i++)
        {
            float3 position = position_temperature_buffer[i].xyz;
            
            position += 0.5f;
            position *= texture_resolution;
            position -= 0.5f;

            const float dist = distance(position, pixel_id);
            if (dist < 1)
            {
                float4 color_temperature_value = color_temperature_texture[pixel_id];

                color_temperature_value.rgb = float3(1, 1, 0);
                
                const float temperature = position_temperature_buffer[i].a;

                const float factor = 1 - dist;
                const float delta = temperature * factor;
                color_temperature_value.a = clamp(color_temperature_value.a + delta, 0, 1);
                
                color_temperature_texture[pixel_id] = color_temperature_value;

                texel_temperature_texture[pixel_id] = float4(pixel_id.x, pixel_id.y, pixel_id.z, color_temperature_value.a);
            }
        }
    }
}

[numthreads(8,8,8)]
void kernel_diffusion (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;
    
    const int3 top_pixel_id    = pixel_id + TOP_OFFSET;
    const int3 bottom_pixel_id = pixel_id + BOTTOM_OFFSET;
    const int3 right_pixel_id  = pixel_id + RIGHT_OFFSET;
    const int3 left_pixel_id   = pixel_id + LEFT_OFFSET;
    const int3 front_pixel_id  = pixel_id + FRONT_OFFSET;
    const int3 back_pixel_id   = pixel_id + BACK_OFFSET;

    const float obstacle_value = get_obstacle(pixel_id);
    
    if (obstacle_value)
    {
        const float top_obstacle_value    = get_obstacle(top_pixel_id);
        const float bottom_obstacle_value = get_obstacle(bottom_pixel_id);
        const float right_obstacle_value  = get_obstacle(right_pixel_id);
        const float left_obstacle_value   = get_obstacle(left_pixel_id);
        const float front_obstacle_value  = get_obstacle(front_pixel_id);
        const float back_obstacle_value   = get_obstacle(back_pixel_id);
    
        const float4 density_value        = color_temperature_texture[pixel_id];
        const float4 top_density_value    = color_temperature_texture[top_pixel_id]    * top_obstacle_value;
        const float4 bottom_density_value = color_temperature_texture[bottom_pixel_id] * bottom_obstacle_value;
        const float4 right_density_value  = color_temperature_texture[right_pixel_id]  * right_obstacle_value;
        const float4 left_density_value   = color_temperature_texture[left_pixel_id]   * left_obstacle_value;
        const float4 front_density_value  = color_temperature_texture[front_pixel_id]  * front_obstacle_value;
        const float4 back_density_value   = color_temperature_texture[back_pixel_id]   * back_obstacle_value;
    
        const float k = delta_time * diffusion_intensity * texture_resolution.x;
        float4 new_density_value =
            (
                density_value
                + k
                * (top_density_value + bottom_density_value + right_density_value + left_density_value + front_density_value + back_density_value)
            )
            / (1 + 6.0 * k);
        
        color_temperature_texture[pixel_id] = new_density_value;
    
        texel_temperature_texture[pixel_id] = float4(pixel_id.x, pixel_id.y, pixel_id.z, new_density_value.a);
    }
}