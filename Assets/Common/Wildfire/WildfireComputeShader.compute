#pragma kernel kernel_init
#pragma kernel kernel_user_input
#pragma kernel kernel_read_data
#pragma kernel kernel_modules_influence
#pragma kernel kernel_diffusion

RWTexture3D<float4> ColorTemperatureTexture;
RWTexture3D<float4> TexelTemperatureTexture;

float3 texture_resolution;
float3 torch_position;

float source_intensity;
float diffusion_intensity;
float delta_time;

int modules_number;

Texture3D myTexture3D;
SamplerState linearClampSampler;

RWStructuredBuffer<float4> posTempBuffer;

RWStructuredBuffer<float4> PositionTemperatureBuffer;

#define TOP_OFFSET    int3( 0, 1, 0)
#define BOTTOM_OFFSET int3( 0,-1, 0)
#define RIGHT_OFFSET  int3( 1, 0, 0)
#define LEFT_OFFSET   int3(-1, 0, 0)
#define FRONT_OFFSET  int3( 0, 0, 1)
#define BACK_OFFSET   int3( 0, 0,-1)

int get_obstacle(const int3 id)
{
    int obstacle = 1;
    
    const float3 padding = 1;
    const float3 volume_size = texture_resolution - padding * 2;
    if (id.x < padding.x || id.y < padding.y || id.z < padding.z
            || id.x > volume_size.x || id.y > volume_size.y || id.z > volume_size.z)
    {
        obstacle = 0;
    }
    
    return obstacle;
}

[numthreads(8,8,8)]
void kernel_init (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;
    
    ColorTemperatureTexture[pixel_id] = 0;
    TexelTemperatureTexture[pixel_id] = 0;
}

[numthreads(8,8,8)]
void kernel_user_input (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;
    
    const int obstacle_value = get_obstacle(pixel_id);
    bool t = true;
    if (t)
    {
        if (source_intensity > 0)
        {
            float3 torch_u_v = torch_position;
            torch_u_v += 0.5f;
            torch_u_v *= texture_resolution;
            torch_u_v -= 0.5f;

            const float dist = distance(torch_u_v, pixel_id);
            if (dist < 1)
            {
                float4 density_value = ColorTemperatureTexture[pixel_id];

                density_value.rgb = float3(1, 1, 0);
            
                const float factor = 0.25f;
                const float delta = source_intensity * factor;
                density_value.a = clamp(density_value.a + delta, 0, 1);

                ColorTemperatureTexture[pixel_id] = density_value;
        
                TexelTemperatureTexture[pixel_id] = float4(0.0f, 0.0f, 0.0f, density_value.a);
            }
        }
    }
}

[numthreads(1,1,1)]
void kernel_read_data (uint3 id : SV_DispatchThreadID)
{
    const int index = id.x;

    /*
    // sample temperature data from texture
    float3 u_v = posTempBuffer[index].xyz;
    u_v += 0.5f;
    float4 val = myTexture3D.SampleLevel(linearClampSampler, u_v, 0);
    posTempBuffer[index].w = val.w;

    // calculate texture position
    u_v *= texture_resolution;
    u_v -= 0.5f;
    posTempBuffer[index].xyz = u_v;
    */

    // решающая

    // calculate module position
    float3 position = posTempBuffer[index].xyz;
    position += 0.5f;
    position *= texture_resolution;

    // grid step
    const float grid_step = 1.0f;
    
    // calculate x pos
    const float x_value = position.x;
    const float x_value_offset = x_value - grid_step / 2.0f;
    const float x_value_offset_step = x_value_offset / grid_step;
    const float floor_x = floor(x_value_offset_step);

    // calculate y pos
    const float y_value = position.y;
    const float y_value_offset = y_value - grid_step / 2.0f;
    const float y_value_offset_step = y_value_offset / grid_step;
    const float floor_y = floor(y_value_offset_step);

    // calculate z pos
    const float z_value = position.z;
    const float z_value_offset = z_value - grid_step / 2.0f;
    const float z_value_offset_step = z_value_offset / grid_step;
    const float floor_z = floor(z_value_offset_step);
       
    
    // calculate factors
    const float dif_x_f = x_value - floor_x; // f
    const float dif_x_s = 1.0f - dif_x_f;    // s

    const float dif_y_f = y_value - floor_y; // f
    const float dif_y_s = 1.0f - dif_y_f;    // s

    const float dif_z_f = z_value - floor_z; // f
    const float dif_z_s = 1.0f - dif_z_f;    // s

    // write factors
    const int3 x_f_y_f_z_f = int3(floor_x, floor_y, floor_z);
    const float factor_f_f_f = dif_x_f * dif_y_f * dif_z_f;

        

    // result
    posTempBuffer[index] = float4(floor_x, floor_y, floor_z, 0.0f);
    
    //posTempBuffer[index] = float4(position.x, position.y, position.z, 0.0f);
}

[numthreads(8,8,8)]
void kernel_modules_influence (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;

    /*
    const int obstacle_value = get_obstacle(pixel_id);
    
    if (obstacle_value)
    {
        for (int i = 0; i < modules_number; i++)
        {
            float3 position = PositionTemperatureBuffer[i].xyz;
            
            position += 0.5f;
            position *= texture_resolution;
            position -= 0.5f;
            
            const float dist = distance(position, pixel_id);
            if (dist < 1)
            {
                float4 color_temperature_value = ColorTemperatureTexture[pixel_id];

                color_temperature_value.rgb = float3(1, 1, 0);
                
                const float temperature = PositionTemperatureBuffer[i].a;

                const float factor = 1 - dist;
                const float delta = temperature * factor;
                color_temperature_value.a = clamp(color_temperature_value.a + delta, 0, 1);
                
                ColorTemperatureTexture[pixel_id] = color_temperature_value;

                TexelTemperatureTexture[pixel_id] = float4(pixel_id.x, pixel_id.y, pixel_id.z, color_temperature_value.a);
            }
        }
    }
    */
}

[numthreads(8,8,8)]
void kernel_diffusion (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;
    
    const int3 top_pixel_id    = pixel_id + TOP_OFFSET;
    const int3 bottom_pixel_id = pixel_id + BOTTOM_OFFSET;
    const int3 right_pixel_id  = pixel_id + RIGHT_OFFSET;
    const int3 left_pixel_id   = pixel_id + LEFT_OFFSET;
    const int3 front_pixel_id  = pixel_id + FRONT_OFFSET;
    const int3 back_pixel_id   = pixel_id + BACK_OFFSET;

    const float obstacle_value = get_obstacle(pixel_id);
    
    if (obstacle_value)
    {
        const float top_obstacle_value    = get_obstacle(top_pixel_id);
        const float bottom_obstacle_value = get_obstacle(bottom_pixel_id);
        const float right_obstacle_value  = get_obstacle(right_pixel_id);
        const float left_obstacle_value   = get_obstacle(left_pixel_id);
        const float front_obstacle_value  = get_obstacle(front_pixel_id);
        const float back_obstacle_value   = get_obstacle(back_pixel_id);
    
        const float4 density_value        = ColorTemperatureTexture[pixel_id];
        const float4 top_density_value    = ColorTemperatureTexture[top_pixel_id]    * top_obstacle_value;
        const float4 bottom_density_value = ColorTemperatureTexture[bottom_pixel_id] * bottom_obstacle_value;
        const float4 right_density_value  = ColorTemperatureTexture[right_pixel_id]  * right_obstacle_value;
        const float4 left_density_value   = ColorTemperatureTexture[left_pixel_id]   * left_obstacle_value;
        const float4 front_density_value  = ColorTemperatureTexture[front_pixel_id]  * front_obstacle_value;
        const float4 back_density_value   = ColorTemperatureTexture[back_pixel_id]   * back_obstacle_value;
    
        const float k = delta_time * diffusion_intensity * texture_resolution.x;
        float4 new_density_value =
            (
                density_value
                + k
                * (top_density_value + bottom_density_value + right_density_value + left_density_value + front_density_value + back_density_value)
            )
            / (1 + 6.0 * k);
        
        ColorTemperatureTexture[pixel_id] = new_density_value;
    
        TexelTemperatureTexture[pixel_id] = float4(pixel_id.x, pixel_id.y, pixel_id.z, new_density_value.a);
    }
}