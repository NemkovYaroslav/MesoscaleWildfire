#pragma kernel kernel_init
#pragma kernel kernel_user_input
#pragma kernel kernel_modules_influence
#pragma kernel kernel_diffusion_velocity
#pragma kernel kernel_divergence;
#pragma kernel kernel_pressure;
#pragma kernel kernel_subtract_gradient
#pragma kernel kernel_advection_velocity
#pragma kernel kernel_advection_temperature
#pragma kernel kernel_diffusion_temperature
#pragma kernel kernel_read_data

RWTexture3D<float4> color_temperature_texture;

RWTexture3D<float3> velocity_texture;

RWTexture3D<float> divergence_texture;
RWTexture3D<float> pressure_texture;

float3 texture_resolution;
float3 area_scale;

float3 torch_position;

float source_intensity;
float diffusion_intensity;
float viscosity_intensity;
float delta_time;

int modules_number;

Texture3D texture_for_sample_temperature;
SamplerState linear_clamp_sampler;

RWStructuredBuffer<float4> pos_for_get_data;

RWStructuredBuffer<float4> pos_for_set_data;

#define TOP_OFFSET    int3( 0, 1, 0)
#define BOTTOM_OFFSET int3( 0,-1, 0)
#define RIGHT_OFFSET  int3( 1, 0, 0)
#define LEFT_OFFSET   int3(-1, 0, 0)
#define FRONT_OFFSET  int3( 0, 0, 1)
#define BACK_OFFSET   int3( 0, 0,-1)

int get_obstacle(const int3 id)
{
    int obstacle = 1;
    
    const float3 padding = 1;
    const float3 volume_size = texture_resolution - padding * 2;
    if (id.x < padding.x || id.y < padding.y || id.z < padding.z
            || id.x > volume_size.x || id.y > volume_size.y || id.z > volume_size.z)
    {
        obstacle = 0;
    }
    
    return obstacle;
}

[numthreads(8,8,8)]
void kernel_init (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;
    
    color_temperature_texture[pixel_id] = 0;
    velocity_texture[pixel_id] = 0;
    divergence_texture[pixel_id] = 0;
    pressure_texture[pixel_id] = 0;
}

[numthreads(1,1,1)]
void kernel_user_input (uint3 id : SV_DispatchThreadID)
{
    if (source_intensity > 0)
    {
        float3 uv = torch_position;
        uv += 0.5f;
        uv *= texture_resolution;

        const float grid_space = 1.0f;
        const float half_grid_space = grid_space / 2.0f;

        const float3 nearest_cell_uv = (uv - half_grid_space);
        const float3 floor_cell_uv = floor(nearest_cell_uv);
        
        const float3 cell_000 = floor_cell_uv;
        const float3 cell_100 = floor_cell_uv + float3(1, 0, 0);
        const float3 cell_010 = floor_cell_uv + float3(0, 1, 0);
        const float3 cell_001 = floor_cell_uv + float3(0, 0, 1);
        const float3 cell_110 = floor_cell_uv + float3(1, 1, 0);
        const float3 cell_101 = floor_cell_uv + float3(1, 0, 1);
        const float3 cell_011 = floor_cell_uv + float3(0, 1, 1);
        const float3 cell_111 = floor_cell_uv + float3(1, 1, 1);

        const float x_1 = nearest_cell_uv.x - floor_cell_uv.x;
        const float x_0 = 1.0f - x_1;

        const float y_1 = nearest_cell_uv.y - floor_cell_uv.y;
        const float y_0 = 1.0f - y_1;

        const float z_1 = nearest_cell_uv.z - floor_cell_uv.z;
        const float z_0 = 1.0f - z_1;

        const float inf_000 = x_0 * y_0 * z_0;
        const float inf_100 = x_1 * y_0 * z_0;
        const float inf_010 = x_0 * y_1 * z_0;
        const float inf_001 = x_0 * y_0 * z_1;
        const float inf_110 = x_1 * y_1 * z_0;
        const float inf_101 = x_1 * y_0 * z_1;
        const float inf_011 = x_0 * y_1 * z_1;
        const float inf_111 = x_1 * y_1 * z_1;

        int neighbours_number = 0;
        if (inf_000 > 0.0f)
        {
            neighbours_number++;
        }
        if (inf_100 > 0.0f)
        {
            neighbours_number++;
        }
        if (inf_010 > 0.0f)
        {
            neighbours_number++;
        }
        if (inf_001 > 0.0f)
        {
            neighbours_number++;
        }
        if (inf_110 > 0.0f)
        {
            neighbours_number++;
        }
        if (inf_101 > 0.0f)
        {
            neighbours_number++;
        }
        if (inf_011 > 0.0f)
        {
            neighbours_number++;
        }
        if (inf_111 > 0.0f)
        {
            neighbours_number++;
        }
        
        const float3 color = float3(1, 1, 0);
    
        const float temperature = source_intensity * neighbours_number;
        
        float4 temperature_cell_000 = color_temperature_texture[cell_000];
        temperature_cell_000.rgb = color;
        const float temperature_000 = temperature * inf_000;
        temperature_cell_000.a = clamp(temperature_cell_000.a + temperature_000, 0.0f, 1.0f);
        color_temperature_texture[cell_000] = temperature_cell_000;

        float4 temperature_cell_100 = color_temperature_texture[cell_100];
        temperature_cell_100.rgb = color;
        const float temperature_100 = temperature * inf_100;
        temperature_cell_100.a = clamp(temperature_cell_100.a + temperature_100, 0.0f, 1.0f);
        color_temperature_texture[cell_100] = temperature_cell_100;

        float4 temperature_cell_010 = color_temperature_texture[cell_010];
        temperature_cell_010.rgb = color;
        const float temperature_010 = temperature * inf_010;
        temperature_cell_010.a = clamp(temperature_cell_010.a + temperature_010, 0.0f, 1.0f);
        color_temperature_texture[cell_010] = temperature_cell_010;

        float4 temperature_cell_001 = color_temperature_texture[cell_001];
        temperature_cell_001.rgb = color;
        const float temperature_001 = temperature * inf_001;
        temperature_cell_001.a = clamp(temperature_cell_001.a + temperature_001, 0.0f, 1.0f);
        color_temperature_texture[cell_001] = temperature_cell_001;

        float4 temperature_cell_110 = color_temperature_texture[cell_110];
        temperature_cell_110.rgb = color;
        const float temperature_110 = temperature * inf_110;
        temperature_cell_110.a = clamp(temperature_cell_110.a + temperature_110, 0.0f, 1.0f);
        color_temperature_texture[cell_110] = temperature_cell_110;

        float4 temperature_cell_101 = color_temperature_texture[cell_101];
        temperature_cell_101.rgb = color;
        const float temperature_101 = temperature * inf_101;
        temperature_cell_101.a = clamp(temperature_cell_101.a + temperature_101, 0.0f, 1.0f);
        color_temperature_texture[cell_101] = temperature_cell_101;

        float4 temperature_cell_011 = color_temperature_texture[cell_011];
        temperature_cell_011.rgb = color;
        const float temperature_011 = temperature * inf_011;
        temperature_cell_011.a = clamp(temperature_cell_011.a + temperature_011, 0.0f, 1.0f);
        color_temperature_texture[cell_011] = temperature_cell_011;

        float4 temperature_cell_111 = color_temperature_texture[cell_111];
        temperature_cell_111.rgb = color;
        const float temperature_111 = temperature * inf_111;
        temperature_cell_111.a = clamp(temperature_cell_111.a + temperature_111, 0.0f, 1.0f);
        color_temperature_texture[cell_111] = temperature_cell_111;
    }
}

[numthreads(8,1,1)]
void kernel_modules_influence (uint3 id : SV_DispatchThreadID)
{
    const int index = id.x;

    float3 uv = pos_for_set_data[index].xyz;
    
    uv += 0.5f;
    uv *= texture_resolution;

    const float grid_space = 1.0f;
    const float half_grid_space = grid_space / 2.0f;

    const float3 nearest_cell_uv = (uv - half_grid_space);
    const float3 floor_cell_uv = floor(nearest_cell_uv);
    
    const float3 cell_000 = floor_cell_uv;
    const float3 cell_100 = floor_cell_uv + float3(1, 0, 0);
    const float3 cell_010 = floor_cell_uv + float3(0, 1, 0);
    const float3 cell_001 = floor_cell_uv + float3(0, 0, 1);
    const float3 cell_110 = floor_cell_uv + float3(1, 1, 0);
    const float3 cell_101 = floor_cell_uv + float3(1, 0, 1);
    const float3 cell_011 = floor_cell_uv + float3(0, 1, 1);
    const float3 cell_111 = floor_cell_uv + float3(1, 1, 1);

    const float x_1 = nearest_cell_uv.x - floor_cell_uv.x;
    const float x_0 = 1.0f - x_1;

    const float y_1 = nearest_cell_uv.y - floor_cell_uv.y;
    const float y_0 = 1.0f - y_1;

    const float z_1 = nearest_cell_uv.z - floor_cell_uv.z;
    const float z_0 = 1.0f - z_1;

    const float inf_000 = x_0 * y_0 * z_0;
    const float inf_100 = x_1 * y_0 * z_0;
    const float inf_010 = x_0 * y_1 * z_0;
    const float inf_001 = x_0 * y_0 * z_1;
    const float inf_110 = x_1 * y_1 * z_0;
    const float inf_101 = x_1 * y_0 * z_1;
    const float inf_011 = x_0 * y_1 * z_1;
    const float inf_111 = x_1 * y_1 * z_1;

    int neighbours_number = 0;
    if (inf_000 > 0.0f)
    {
        neighbours_number++;
    }
    if (inf_100 > 0.0f)
    {
        neighbours_number++;
    }
    if (inf_010 > 0.0f)
    {
        neighbours_number++;
    }
    if (inf_001 > 0.0f)
    {
        neighbours_number++;
    }
    if (inf_110 > 0.0f)
    {
        neighbours_number++;
    }
    if (inf_101 > 0.0f)
    {
        neighbours_number++;
    }
    if (inf_011 > 0.0f)
    {
        neighbours_number++;
    }
    if (inf_111 > 0.0f)
    {
        neighbours_number++;
    }
    
    const float3 color = float3(1, 1, 0);
    
    const float temperature = pos_for_set_data[index].a * neighbours_number;
    
    float4 temperature_cell_000 = color_temperature_texture[cell_000];
    temperature_cell_000.rgb = color;
    const float temperature_000 = temperature * inf_000;
    temperature_cell_000.a = clamp(temperature_cell_000.a + temperature_000, 0.0f, 1.0f);
    color_temperature_texture[cell_000] = temperature_cell_000;

    float4 temperature_cell_100 = color_temperature_texture[cell_100];
    temperature_cell_100.rgb = color;
    const float temperature_100 = temperature * inf_100;
    temperature_cell_100.a = clamp(temperature_cell_100.a + temperature_100, 0.0f, 1.0f);
    color_temperature_texture[cell_100] = temperature_cell_100;

    float4 temperature_cell_010 = color_temperature_texture[cell_010];
    temperature_cell_010.rgb = color;
    const float temperature_010 = temperature * inf_010;
    temperature_cell_010.a = clamp(temperature_cell_010.a + temperature_010, 0.0f, 1.0f);
    color_temperature_texture[cell_010] = temperature_cell_010;

    float4 temperature_cell_001 = color_temperature_texture[cell_001];
    temperature_cell_001.rgb = color;
    const float temperature_001 = temperature * inf_001;
    temperature_cell_001.a = clamp(temperature_cell_001.a + temperature_001, 0.0f, 1.0f);
    color_temperature_texture[cell_001] = temperature_cell_001;

    float4 temperature_cell_110 = color_temperature_texture[cell_110];
    temperature_cell_110.rgb = color;
    const float temperature_110 = temperature * inf_110;
    temperature_cell_110.a = clamp(temperature_cell_110.a + temperature_110, 0.0f, 1.0f);
    color_temperature_texture[cell_110] = temperature_cell_110;

    float4 temperature_cell_101 = color_temperature_texture[cell_101];
    temperature_cell_101.rgb = color;
    const float temperature_101 = temperature * inf_101;
    temperature_cell_101.a = clamp(temperature_cell_101.a + temperature_101, 0.0f, 1.0f);
    color_temperature_texture[cell_101] = temperature_cell_101;

    float4 temperature_cell_011 = color_temperature_texture[cell_011];
    temperature_cell_011.rgb = color;
    const float temperature_011 = temperature * inf_011;
    temperature_cell_011.a = clamp(temperature_cell_011.a + temperature_011, 0.0f, 1.0f);
    color_temperature_texture[cell_011] = temperature_cell_011;

    float4 temperature_cell_111 = color_temperature_texture[cell_111];
    temperature_cell_111.rgb = color;
    const float temperature_111 = temperature * inf_111;
    temperature_cell_111.a = clamp(temperature_cell_111.a + temperature_111, 0.0f, 1.0f);
    color_temperature_texture[cell_111] = temperature_cell_111;
}

[numthreads(8,8,8)]
void kernel_diffusion_velocity (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;
    
    const int3 top_pixel_id    = pixel_id + TOP_OFFSET;
    const int3 bottom_pixel_id = pixel_id + BOTTOM_OFFSET;
    const int3 right_pixel_id  = pixel_id + RIGHT_OFFSET;
    const int3 left_pixel_id   = pixel_id + LEFT_OFFSET;
    const int3 front_pixel_id  = pixel_id + FRONT_OFFSET;
    const int3 back_pixel_id   = pixel_id + BACK_OFFSET;

    const float3 velocity_value        = velocity_texture[pixel_id];
    const float3 top_velocity_value    = velocity_texture[top_pixel_id]; 
    const float3 bottom_velocity_value = velocity_texture[bottom_pixel_id];
    const float3 right_velocity_value  = velocity_texture[right_pixel_id];
    const float3 left_velocity_value   = velocity_texture[left_pixel_id]; 
    const float3 front_velocity_value  = velocity_texture[front_pixel_id];
    const float3 back_velocity_value   = velocity_texture[back_pixel_id];

    const float resolution = (texture_resolution.x + texture_resolution.y + texture_resolution.z) / 2.0f;
    
    //const float k = delta_time * viscosity * texture_resolution.x * texture_resolution.y;
    const float k = delta_time * viscosity_intensity * resolution;
    const float3 velocity =
    (
        velocity_value
            + k
                * (top_velocity_value + bottom_velocity_value + right_velocity_value + left_velocity_value + front_velocity_value + back_velocity_value)
    )
    / (1 + 6.0 * k);
    
    velocity_texture[pixel_id] = velocity;
}

[numthreads(8,8,8)]
void kernel_divergence (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;
    
    const int3 top_pixel_id    = pixel_id + TOP_OFFSET;
    const int3 bottom_pixel_id = pixel_id + BOTTOM_OFFSET;
    const int3 right_pixel_id  = pixel_id + RIGHT_OFFSET;
    const int3 left_pixel_id   = pixel_id + LEFT_OFFSET;
    const int3 front_pixel_id  = pixel_id + FRONT_OFFSET;
    const int3 back_pixel_id   = pixel_id + BACK_OFFSET;
        
    const float3 top_velocity_value    = velocity_texture[top_pixel_id];  
    const float3 bottom_velocity_value = velocity_texture[bottom_pixel_id];
    const float3 right_velocity_value  = velocity_texture[right_pixel_id];
    const float3 left_velocity_value   = velocity_texture[left_pixel_id];  
    const float3 front_velocity_value  = velocity_texture[front_pixel_id]; 
    const float3 back_velocity_value   = velocity_texture[back_pixel_id];  

    /*
    const float divergence
        = 0.5f
            * (right_velocity_value.x - left_velocity_value.x
                + top_velocity_value.y - bottom_velocity_value.y
                    + front_velocity_value.z - back_velocity_value.z)
                        / texture_resolution.x;
    */

    const float resolution = (texture_resolution.x + texture_resolution.y + texture_resolution.z) / 2.0f;

    const float divergence
    = 0.5f
        * (right_velocity_value.x - left_velocity_value.x
            + top_velocity_value.y - bottom_velocity_value.y
                + front_velocity_value.z - back_velocity_value.z)
                    / resolution;
    
    divergence_texture[pixel_id] = divergence;

    pressure_texture[pixel_id] = 0;
}

[numthreads(8,8,8)]
void kernel_pressure (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;
    
    const int3 top_pixel_id    = pixel_id + TOP_OFFSET;
    const int3 bottom_pixel_id = pixel_id + BOTTOM_OFFSET;
    const int3 right_pixel_id  = pixel_id + RIGHT_OFFSET;
    const int3 left_pixel_id   = pixel_id + LEFT_OFFSET;
    const int3 front_pixel_id  = pixel_id + FRONT_OFFSET;
    const int3 back_pixel_id   = pixel_id + BACK_OFFSET;
    
    const float top_pressure_value    = pressure_texture[top_pixel_id];
    const float bottom_pressure_value = pressure_texture[bottom_pixel_id];
    const float right_pressure_value  = pressure_texture[right_pixel_id];
    const float left_pressure_value   = pressure_texture[left_pixel_id];
    const float front_pressure_value  = pressure_texture[front_pixel_id];
    const float back_pressure_value   = pressure_texture[back_pixel_id];
    
    //const float divergence_value = divergence_texture[pixel_id];
    //const float divergence_value = divergence_texture[pixel_id] * texture_resolution.x;

    const float resolution = (texture_resolution.x + texture_resolution.y + texture_resolution.z) / 2.0f;
    const float divergence_value = divergence_texture[pixel_id] * resolution;
    
    const float pressure
        = (
            left_pressure_value + right_pressure_value
                + bottom_pressure_value + top_pressure_value
                    + front_pressure_value + back_pressure_value
                        - divergence_value
        ) / 6.0;

    pressure_texture[pixel_id] = pressure;
}

[numthreads(8,8,8)]
void kernel_subtract_gradient (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;
    
    const int3 top_pixel_id    = pixel_id + TOP_OFFSET;
    const int3 bottom_pixel_id = pixel_id + BOTTOM_OFFSET;
    const int3 right_pixel_id  = pixel_id + RIGHT_OFFSET;
    const int3 left_pixel_id   = pixel_id + LEFT_OFFSET;
    const int3 front_pixel_id  = pixel_id + FRONT_OFFSET;
    const int3 back_pixel_id   = pixel_id + BACK_OFFSET;
    
    const float top_pressure_value    = pressure_texture[top_pixel_id];
    const float bottom_pressure_value = pressure_texture[bottom_pixel_id];
    const float right_pressure_value  = pressure_texture[right_pixel_id];
    const float left_pressure_value   = pressure_texture[left_pixel_id];
    const float front_pressure_value  = pressure_texture[front_pixel_id];
    const float back_pressure_value   = pressure_texture[back_pixel_id];
    
    //const float vel_x = 0.5f * (right_pressure_value - left_pressure_value) * texture_resolution.x;
    //const float vel_y = 0.5f * (top_pressure_value - bottom_pressure_value) * texture_resolution.x;
    //const float vel_z = 0.5f * (front_pressure_value - back_pressure_value) * texture_resolution.x;

    const float vel_x = 1.0f * (right_pressure_value - left_pressure_value);
    const float vel_y = 1.0f * (top_pressure_value - bottom_pressure_value);
    const float vel_z = 1.0f * (front_pressure_value - back_pressure_value);
    
    velocity_texture[pixel_id] -= float3(vel_x, vel_y, vel_z);
}

[numthreads(8,8,8)]
void kernel_advection_velocity (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;

    const float resolution = (texture_resolution.x + texture_resolution.y + texture_resolution.z) / 2.0f;
    
    //const float3 displacement = delta_time * resolution * velocity_texture[pixel_id];

    const float3 air_velocity = float3(0, 0.1f, 0);
    const float3 displacement = delta_time * resolution * air_velocity;
    
    const float3 previous_uv = float3(pixel_id) - displacement;

    const float3 cell_000 = floor(previous_uv);
    const float3 cell_100 = cell_000 + float3(1, 0, 0);
    const float3 cell_010 = cell_000 + float3(0, 1, 0);
    const float3 cell_001 = cell_000 + float3(0, 0, 1);
    const float3 cell_110 = cell_000 + float3(1, 1, 0);
    const float3 cell_101 = cell_000 + float3(1, 0, 1);
    const float3 cell_011 = cell_000 + float3(0, 1, 1);
    const float3 cell_111 = cell_000 + float3(1, 1, 1);

    const float3 velocity_000 = velocity_texture[cell_000];
    const float3 velocity_100 = velocity_texture[cell_100];
    const float3 velocity_010 = velocity_texture[cell_010];
    const float3 velocity_001 = velocity_texture[cell_001];
    const float3 velocity_110 = velocity_texture[cell_110];
    const float3 velocity_101 = velocity_texture[cell_101];
    const float3 velocity_011 = velocity_texture[cell_011];
    const float3 velocity_111 = velocity_texture[cell_111];

    const float x_1 = previous_uv.x - cell_000.x;
    const float x_0 = 1.0f - x_1;

    const float y_1 = previous_uv.y - cell_000.y;
    const float y_0 = 1.0f - y_1;

    const float z_1 = previous_uv.z - cell_000.z;
    const float z_0 = 1.0f - z_1;

    const float inf_000 = x_0 * y_0 * z_0;
    const float inf_100 = x_1 * y_0 * z_0;
    const float inf_010 = x_0 * y_1 * z_0;
    const float inf_001 = x_0 * y_0 * z_1;
    const float inf_110 = x_1 * y_1 * z_0;
    const float inf_101 = x_1 * y_0 * z_1;
    const float inf_011 = x_0 * y_1 * z_1;
    const float inf_111 = x_1 * y_1 * z_1;
    
    const float3 velocity
        = velocity_000 * inf_000
            + velocity_100 * inf_100
                + velocity_010 * inf_010
                    + velocity_001 * inf_001
                        + velocity_110 * inf_110
                            + velocity_101 * inf_101
                                + velocity_011 * inf_011
                                    + velocity_111* inf_111;

    velocity_texture[pixel_id] = velocity;
}

[numthreads(8,8,8)]
void kernel_advection_temperature (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;

    const float resolution = (texture_resolution.x + texture_resolution.y + texture_resolution.z) / 2.0f;

    //const float3 displacement = delta_time * resolution * velocity_texture[pixel_id];

    const float3 air_velocity = float3(0, 0.1f, 0);
    const float3 displacement = delta_time * resolution * air_velocity;
    
    const float3 previous_uv = float3(pixel_id) - displacement;

    const float3 cell_000 = floor(previous_uv);
    const float3 cell_100 = cell_000 + float3(1, 0, 0);
    const float3 cell_010 = cell_000 + float3(0, 1, 0);
    const float3 cell_001 = cell_000 + float3(0, 0, 1);
    const float3 cell_110 = cell_000 + float3(1, 1, 0);
    const float3 cell_101 = cell_000 + float3(1, 0, 1);
    const float3 cell_011 = cell_000 + float3(0, 1, 1);
    const float3 cell_111 = cell_000 + float3(1, 1, 1);

    const float4 temperature_000 = color_temperature_texture[cell_000];
    const float4 temperature_100 = color_temperature_texture[cell_100];
    const float4 temperature_010 = color_temperature_texture[cell_010];
    const float4 temperature_001 = color_temperature_texture[cell_001];
    const float4 temperature_110 = color_temperature_texture[cell_110];
    const float4 temperature_101 = color_temperature_texture[cell_101];
    const float4 temperature_011 = color_temperature_texture[cell_011];
    const float4 temperature_111 = color_temperature_texture[cell_111];

    const float x_1 = previous_uv.x - cell_000.x;
    const float x_0 = 1.0f - x_1;

    const float y_1 = previous_uv.y - cell_000.y;
    const float y_0 = 1.0f - y_1;

    const float z_1 = previous_uv.z - cell_000.z;
    const float z_0 = 1.0f - z_1;

    const float inf_000 = x_0 * y_0 * z_0;
    const float inf_100 = x_1 * y_0 * z_0;
    const float inf_010 = x_0 * y_1 * z_0;
    const float inf_001 = x_0 * y_0 * z_1;
    const float inf_110 = x_1 * y_1 * z_0;
    const float inf_101 = x_1 * y_0 * z_1;
    const float inf_011 = x_0 * y_1 * z_1;
    const float inf_111 = x_1 * y_1 * z_1;
    
    const float4 temperature
        = temperature_000 * inf_000
            + temperature_100 * inf_100
                + temperature_010 * inf_010
                    + temperature_001 * inf_001
                        + temperature_110 * inf_110
                            + temperature_101 * inf_101
                                + temperature_011 * inf_011
                                    + temperature_111* inf_111;

    color_temperature_texture[pixel_id] = temperature;
}

[numthreads(8,8,8)]
void kernel_diffusion_temperature (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;
    
    const int3 top_pixel_id    = pixel_id + TOP_OFFSET;
    const int3 bottom_pixel_id = pixel_id + BOTTOM_OFFSET;
    const int3 right_pixel_id  = pixel_id + RIGHT_OFFSET;
    const int3 left_pixel_id   = pixel_id + LEFT_OFFSET;
    const int3 front_pixel_id  = pixel_id + FRONT_OFFSET;
    const int3 back_pixel_id   = pixel_id + BACK_OFFSET;

    const float4 density_value = color_temperature_texture[pixel_id];
    const float4 top_density_value    = color_temperature_texture[top_pixel_id];
    const float4 bottom_density_value = color_temperature_texture[bottom_pixel_id];
    const float4 right_density_value  = color_temperature_texture[right_pixel_id];
    const float4 left_density_value   = color_temperature_texture[left_pixel_id]; 
    const float4 front_density_value  = color_temperature_texture[front_pixel_id];
    const float4 back_density_value   = color_temperature_texture[back_pixel_id]; 

    const float resolution = (texture_resolution.x + texture_resolution.y + texture_resolution.z) / 2.0f;
    const float k = delta_time * diffusion_intensity * resolution;
    const float4 new_density_value =
    (
        density_value
        + k
        * (top_density_value + bottom_density_value + right_density_value + left_density_value + front_density_value + back_density_value)
    )
    / (1 + 6.0 * k);
    
    color_temperature_texture[pixel_id] = new_density_value;
}

[numthreads(8,1,1)]
void kernel_read_data (uint3 id : SV_DispatchThreadID)
{
    const int index = id.x;
    
    // sample temperature data from texture
    float3 uv = pos_for_get_data[index].xyz;
    uv += 0.5f;
    float4 val = texture_for_sample_temperature.SampleLevel(linear_clamp_sampler, uv, 0);
    pos_for_get_data[index].w = val.w;
    
    // calculate texture position
    uv *= texture_resolution;
    uv -= 0.5f;
    pos_for_get_data[index].xyz = uv;
}