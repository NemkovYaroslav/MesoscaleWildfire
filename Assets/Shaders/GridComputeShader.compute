#pragma kernel kernel_init // 0
#pragma kernel kernel_user_input // 1

#pragma kernel kernel_read_data // 2
#pragma kernel kernel_write_data // 3

#pragma kernel kernel_diffusion_velocity // 4
#pragma kernel kernel_divergence; // 5
#pragma kernel kernel_pressure; // 6
#pragma kernel kernel_subtract_gradient // 7
#pragma kernel kernel_advection_velocity // 8
#pragma kernel kernel_advection_temperature // 9
#pragma kernel kernel_diffusion_temperature // 10

#pragma kernel kernel_simulate_wind // 11

RWTexture3D<float4> color_temperature_texture;
RWTexture3D<float3> velocity_texture;
RWTexture3D<float>  divergence_texture;
RWTexture3D<float>  pressure_texture;

float3 texture_resolution;

float3 torch_position;

float diffusion_intensity;
float viscosity_intensity;
float delta_time;

RWStructuredBuffer<float3> module_positions;

Texture3D texture_for_sample_ambient_temperature;
SamplerState linear_clamp_sampler;

RWStructuredBuffer<float> get_data;
RWStructuredBuffer<float> set_data;

float3 wind_direction;
float  wind_intensity;

#define TOP_OFFSET    int3( 0, 1, 0)
#define BOTTOM_OFFSET int3( 0,-1, 0)
#define RIGHT_OFFSET  int3( 1, 0, 0)
#define LEFT_OFFSET   int3(-1, 0, 0)
#define FRONT_OFFSET  int3( 0, 0, 1)
#define BACK_OFFSET   int3( 0, 0,-1)

int get_obstacle(const int3 id)
{
    int obstacle = 1;
    
    const float3 padding = 1;
    const float3 volume_size = texture_resolution - padding * 2;
    if (id.x < padding.x || id.y < padding.y || id.z < padding.z
            || id.x > volume_size.x || id.y > volume_size.y || id.z > volume_size.z)
    {
        obstacle = 0;
    }
    
    return obstacle;
}

[numthreads(8,8,8)]
void kernel_init (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;
    
    color_temperature_texture[pixel_id] = 0;
    velocity_texture[pixel_id]          = 0;
    divergence_texture[pixel_id]        = 0;
    pressure_texture[pixel_id]          = 0;
}

[numthreads(1,1,1)]
void kernel_user_input ()
{
    float3 uv = torch_position;
    uv += 0.5f;
    uv *= texture_resolution;
    
    const float3 position = floor(uv);

    const float obstacle = get_obstacle(position);
    if (obstacle)
    {
        float4 temperature = color_temperature_texture[position];

        temperature.rgb = float3(1,0,0);
        temperature.a   = 1.0f;
    
        color_temperature_texture[position] = temperature;
    }
}

[numthreads(8,1,1)]
void kernel_read_data (uint3 id : SV_DispatchThreadID)
{
    const int index = id.x;
    
    // sample temperature data from texture
    float3 uv = module_positions[index].xyz;
    uv += 0.5f;
    
    float4 temperature = texture_for_sample_ambient_temperature.SampleLevel(linear_clamp_sampler, uv, 0);
    get_data[index] = temperature.w;
}

[numthreads(8,1,1)]
void kernel_write_data (uint3 id : SV_DispatchThreadID)
{
    const int index = id.x;

    float3 uv = module_positions[index].xyz;
    uv += 0.5f;
    uv *= texture_resolution;
    
    const float3 position = floor(uv);

    const float obstacle = get_obstacle(position);
    if (obstacle)
    {
        float4 current_temperature = color_temperature_texture[position];
    
        current_temperature.rgb = float3(1,0,0);
        current_temperature.a   = clamp(current_temperature.a + set_data[index], 0, 1);
    
        color_temperature_texture[position] = current_temperature;
    }
}

[numthreads(8,8,8)]
void kernel_diffusion_velocity (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;

    const float obstacle = get_obstacle(pixel_id);
    if (obstacle)
    {
        const int3 top_pixel_id    = pixel_id + TOP_OFFSET;
        const int3 bottom_pixel_id = pixel_id + BOTTOM_OFFSET;
        const int3 right_pixel_id  = pixel_id + RIGHT_OFFSET;
        const int3 left_pixel_id   = pixel_id + LEFT_OFFSET;
        const int3 front_pixel_id  = pixel_id + FRONT_OFFSET;
        const int3 back_pixel_id   = pixel_id + BACK_OFFSET;
        
        const float top_obstacle    = get_obstacle(top_pixel_id);
        const float bottom_obstacle = get_obstacle(bottom_pixel_id);
        const float right_obstacle  = get_obstacle(right_pixel_id);
        const float left_obstacle   = get_obstacle(left_pixel_id);
        const float front_obstacle  = get_obstacle(front_pixel_id);
        const float back_obstacle   = get_obstacle(back_pixel_id);

        const float3 velocity_value = velocity_texture[pixel_id];
        const float3 top_velocity_value    = velocity_texture[top_pixel_id]    * top_obstacle; 
        const float3 bottom_velocity_value = velocity_texture[bottom_pixel_id] * bottom_obstacle;
        const float3 right_velocity_value  = velocity_texture[right_pixel_id]  * right_obstacle;
        const float3 left_velocity_value   = velocity_texture[left_pixel_id]   * left_obstacle; 
        const float3 front_velocity_value  = velocity_texture[front_pixel_id]  * front_obstacle;
        const float3 back_velocity_value   = velocity_texture[back_pixel_id]   * back_obstacle;

        const float resolution = (texture_resolution.x + texture_resolution.y + texture_resolution.z) / 3.0f;
        const float k = delta_time * viscosity_intensity * resolution;
        
        const float3 velocity =
        (
            velocity_value
                + k
                    * (top_velocity_value + bottom_velocity_value + right_velocity_value + left_velocity_value + front_velocity_value + back_velocity_value)
        )
        / (1 + 6.0 * k);
    
        velocity_texture[pixel_id] = velocity;
    }
}

[numthreads(8,8,8)]
void kernel_divergence (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;

    const float obstacle = get_obstacle(pixel_id);
    if (obstacle)
    {
        const int3 top_pixel_id    = pixel_id + TOP_OFFSET;
        const int3 bottom_pixel_id = pixel_id + BOTTOM_OFFSET;
        const int3 right_pixel_id  = pixel_id + RIGHT_OFFSET;
        const int3 left_pixel_id   = pixel_id + LEFT_OFFSET;
        const int3 front_pixel_id  = pixel_id + FRONT_OFFSET;
        const int3 back_pixel_id   = pixel_id + BACK_OFFSET;
    
        const float top_obstacle    = get_obstacle(top_pixel_id);
        const float bottom_obstacle = get_obstacle(bottom_pixel_id);
        const float right_obstacle  = get_obstacle(right_pixel_id);
        const float left_obstacle   = get_obstacle(left_pixel_id);
        const float front_obstacle  = get_obstacle(front_pixel_id);
        const float back_obstacle   = get_obstacle(back_pixel_id);
        
        const float3 top_velocity_value    = velocity_texture[top_pixel_id]    * top_obstacle;  
        const float3 bottom_velocity_value = velocity_texture[bottom_pixel_id] * bottom_obstacle;
        const float3 right_velocity_value  = velocity_texture[right_pixel_id]  * right_obstacle;
        const float3 left_velocity_value   = velocity_texture[left_pixel_id]   * left_obstacle;  
        const float3 front_velocity_value  = velocity_texture[front_pixel_id]  * front_obstacle; 
        const float3 back_velocity_value   = velocity_texture[back_pixel_id]   * back_obstacle;   

        const float resolution = (texture_resolution.x + texture_resolution.y + texture_resolution.z) / 3.0f;

        const float divergence
        = 0.5f
            * (right_velocity_value.x - left_velocity_value.x
                + top_velocity_value.y - bottom_velocity_value.y
                    + front_velocity_value.z - back_velocity_value.z)
                        / resolution;
    
        divergence_texture[pixel_id] = divergence;

        pressure_texture[pixel_id] = 0;
    }
}

[numthreads(8,8,8)]
void kernel_pressure (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;

    const float obstacle = get_obstacle(pixel_id);
    if (obstacle)
    {
        const int3 top_pixel_id    = pixel_id + TOP_OFFSET;
        const int3 bottom_pixel_id = pixel_id + BOTTOM_OFFSET;
        const int3 right_pixel_id  = pixel_id + RIGHT_OFFSET;
        const int3 left_pixel_id   = pixel_id + LEFT_OFFSET;
        const int3 front_pixel_id  = pixel_id + FRONT_OFFSET;
        const int3 back_pixel_id   = pixel_id + BACK_OFFSET;

        const float top_obstacle    = get_obstacle(top_pixel_id);
        const float bottom_obstacle = get_obstacle(bottom_pixel_id);
        const float right_obstacle  = get_obstacle(right_pixel_id);
        const float left_obstacle   = get_obstacle(left_pixel_id);
        const float front_obstacle  = get_obstacle(front_pixel_id);
        const float back_obstacle   = get_obstacle(back_pixel_id);

        const float pressure_value = pressure_texture[pixel_id];
        const float top_pressure_value    = lerp(pressure_value, pressure_texture[top_pixel_id],    top_obstacle);
        const float bottom_pressure_value = lerp(pressure_value, pressure_texture[bottom_pixel_id], bottom_obstacle);
        const float right_pressure_value  = lerp(pressure_value, pressure_texture[right_pixel_id],  right_obstacle);
        const float left_pressure_value   = lerp(pressure_value, pressure_texture[left_pixel_id],   left_obstacle);
        const float front_pressure_value  = lerp(pressure_value, pressure_texture[front_pixel_id],  front_obstacle);
        const float back_pressure_value   = lerp(pressure_value, pressure_texture[back_pixel_id],   back_obstacle);
    
        //const float divergence_value = divergence_texture[pixel_id];
        //const float divergence_value = divergence_texture[pixel_id] * texture_resolution.x;

        //const float divergence_value = divergence_texture[pixel_id];
        
        const float resolution = (texture_resolution.x + texture_resolution.y + texture_resolution.z) / 3.0f;
        const float divergence_value = divergence_texture[pixel_id] * resolution;
    
        const float pressure
            = (
                left_pressure_value + right_pressure_value
                    + bottom_pressure_value + top_pressure_value
                        + front_pressure_value + back_pressure_value
                            - divergence_value
            ) / 6.0;

        pressure_texture[pixel_id] = pressure;
    }
}

[numthreads(8,8,8)]
void kernel_subtract_gradient (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;

    const float obstacle = get_obstacle(pixel_id);
    if (obstacle)
    {
        const int3 top_pixel_id    = pixel_id + TOP_OFFSET;
        const int3 bottom_pixel_id = pixel_id + BOTTOM_OFFSET;
        const int3 right_pixel_id  = pixel_id + RIGHT_OFFSET;
        const int3 left_pixel_id   = pixel_id + LEFT_OFFSET;
        const int3 front_pixel_id  = pixel_id + FRONT_OFFSET;
        const int3 back_pixel_id   = pixel_id + BACK_OFFSET;
    
        const float top_obstacle    = get_obstacle(top_pixel_id);
        const float bottom_obstacle = get_obstacle(bottom_pixel_id);
        const float right_obstacle  = get_obstacle(right_pixel_id);
        const float left_obstacle   = get_obstacle(left_pixel_id);
        const float front_obstacle  = get_obstacle(front_pixel_id);
        const float back_obstacle   = get_obstacle(back_pixel_id);

        const float pressure_value = pressure_texture[pixel_id];
        const float top_pressure_value    = lerp(pressure_value, pressure_texture[top_pixel_id],    top_obstacle);
        const float bottom_pressure_value = lerp(pressure_value, pressure_texture[bottom_pixel_id], bottom_obstacle);
        const float right_pressure_value  = lerp(pressure_value, pressure_texture[right_pixel_id],  right_obstacle);
        const float left_pressure_value   = lerp(pressure_value, pressure_texture[left_pixel_id],   left_obstacle);
        const float front_pressure_value  = lerp(pressure_value, pressure_texture[front_pixel_id],  front_obstacle);
        const float back_pressure_value   = lerp(pressure_value, pressure_texture[back_pixel_id],   back_obstacle);

        //const float resolution = (texture_resolution.x + texture_resolution.y + texture_resolution.z) / 3.0f;
        //const float vel_x = 0.5f * (right_pressure_value - left_pressure_value) * resolution;
        //const float vel_y = 0.5f * (top_pressure_value - bottom_pressure_value) * resolution;
        //const float vel_z = 0.5f * (front_pressure_value - back_pressure_value) * resolution;

        const float curl_size = 0.2f;
        const float vel_x = (right_pressure_value - left_pressure_value) * curl_size;
        const float vel_y = (top_pressure_value - bottom_pressure_value) * curl_size;
        const float vel_z = (front_pressure_value - back_pressure_value) * curl_size;
    
        velocity_texture[pixel_id] -= float3(vel_x, vel_y, vel_z);
    }
}

[numthreads(8,8,8)]
void kernel_advection_velocity (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;
    
    const float obstacle = get_obstacle(pixel_id);
    if (obstacle)
    {
        const float3 grid_velocity = velocity_texture[pixel_id];
    
        if (grid_velocity.x > 0 || grid_velocity.y > 0 || grid_velocity.z > 0)
        {
            const float resolution = (texture_resolution.x + texture_resolution.y + texture_resolution.z) / 3.0f;
            
            const float3 displacement = delta_time * resolution * grid_velocity;
            float3 previous_uv = float3(pixel_id) - displacement;

            
            const int3 padding = int3(1,1,1);
            if (previous_uv.x < padding.x)
            {
                previous_uv.x = padding.x;
            }
            if (previous_uv.y < padding.y)
            {
                previous_uv.y = padding.y;
            }
            if (previous_uv.z < padding.z)
            {
                previous_uv.z = padding.z;
            }
            
            const int3 volume = texture_resolution - padding * 2;
            if (previous_uv.x > volume.x)
            {
                previous_uv.x = volume.x;
            }
            if (previous_uv.y > volume.y)
            {
                previous_uv.y = volume.y;
            }
            if (previous_uv.z > volume.z)
            {
                previous_uv.z = volume.z;
            }
            
            
            const int3 cell_000 = floor(previous_uv);
            const int3 cell_100 = cell_000 + int3(1, 0, 0);
            const int3 cell_010 = cell_000 + int3(0, 1, 0);
            const int3 cell_001 = cell_000 + int3(0, 0, 1);
            const int3 cell_110 = cell_000 + int3(1, 1, 0);
            const int3 cell_101 = cell_000 + int3(1, 0, 1);
            const int3 cell_011 = cell_000 + int3(0, 1, 1);
            const int3 cell_111 = cell_000 + int3(1, 1, 1);
            
            const float obstacle_000 = get_obstacle(cell_000);
            const float obstacle_100 = get_obstacle(cell_100);
            const float obstacle_010 = get_obstacle(cell_010);
            const float obstacle_001 = get_obstacle(cell_001);
            const float obstacle_110 = get_obstacle(cell_110);
            const float obstacle_101 = get_obstacle(cell_101);
            const float obstacle_011 = get_obstacle(cell_011);
            const float obstacle_111 = get_obstacle(cell_111);

            const float3 velocity_000 = velocity_texture[cell_000] * obstacle_000;
            const float3 velocity_100 = velocity_texture[cell_100] * obstacle_100;
            const float3 velocity_010 = velocity_texture[cell_010] * obstacle_010;
            const float3 velocity_001 = velocity_texture[cell_001] * obstacle_001;
            const float3 velocity_110 = velocity_texture[cell_110] * obstacle_110;
            const float3 velocity_101 = velocity_texture[cell_101] * obstacle_101;
            const float3 velocity_011 = velocity_texture[cell_011] * obstacle_011;
            const float3 velocity_111 = velocity_texture[cell_111] * obstacle_111;

            const float x_1 = previous_uv.x - cell_000.x;
            const float x_0 = 1.0f - x_1;

            const float y_1 = previous_uv.y - cell_000.y;
            const float y_0 = 1.0f - y_1;

            const float z_1 = previous_uv.z - cell_000.z;
            const float z_0 = 1.0f - z_1;

            const float inf_000 = x_0 * y_0 * z_0;
            const float inf_100 = x_1 * y_0 * z_0;
            const float inf_010 = x_0 * y_1 * z_0;
            const float inf_001 = x_0 * y_0 * z_1;
            const float inf_110 = x_1 * y_1 * z_0;
            const float inf_101 = x_1 * y_0 * z_1;
            const float inf_011 = x_0 * y_1 * z_1;
            const float inf_111 = x_1 * y_1 * z_1;
        
            float3 velocity
                = velocity_000 * inf_000
                    + velocity_100 * inf_100
                        + velocity_010 * inf_010
                            + velocity_001 * inf_001
                                + velocity_110 * inf_110
                                    + velocity_101 * inf_101
                                        + velocity_011 * inf_011
                                            + velocity_111 * inf_111;

            velocity_texture[pixel_id] = velocity;
        }
    }
}

[numthreads(8,8,8)]
void kernel_advection_temperature (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;

    const float obstacle = get_obstacle(pixel_id);
    if (obstacle)
    {
        const float3 grid_velocity = velocity_texture[pixel_id];
        
        if (grid_velocity.x > 0 || grid_velocity.y > 0 || grid_velocity.z > 0)
        {
            const float resolution = (texture_resolution.x + texture_resolution.y + texture_resolution.z) / 3.0f;
            const float3 displacement = delta_time * resolution * grid_velocity;
            
            float3 previous_uv = float3(pixel_id) - displacement;

            
            const int3 padding = int3(1,1,1);
            if (previous_uv.x < padding.x)
            {
                previous_uv.x = padding.x;
            }
            if (previous_uv.y < padding.y)
            {
                previous_uv.y = padding.y;
            }
            if (previous_uv.z < padding.z)
            {
                previous_uv.z = padding.z;
            }
            
            const int3 volume = texture_resolution - padding * 2;
            if (previous_uv.x > volume.x)
            {
                previous_uv.x = volume.x;
            }
            if (previous_uv.y > volume.y)
            {
                previous_uv.y = volume.y;
            }
            if (previous_uv.z > volume.z)
            {
                previous_uv.z = volume.z;
            }
            
            
            const int3 cell_000 = floor(previous_uv);
            const int3 cell_100 = cell_000 + int3(1, 0, 0);
            const int3 cell_010 = cell_000 + int3(0, 1, 0);
            const int3 cell_001 = cell_000 + int3(0, 0, 1);
            const int3 cell_110 = cell_000 + int3(1, 1, 0);
            const int3 cell_101 = cell_000 + int3(1, 0, 1);
            const int3 cell_011 = cell_000 + int3(0, 1, 1);
            const int3 cell_111 = cell_000 + int3(1, 1, 1);

            const float obstacle_000 = get_obstacle(cell_000);
            const float obstacle_100 = get_obstacle(cell_100);
            const float obstacle_010 = get_obstacle(cell_010);
            const float obstacle_001 = get_obstacle(cell_001);
            const float obstacle_110 = get_obstacle(cell_110);
            const float obstacle_101 = get_obstacle(cell_101);
            const float obstacle_011 = get_obstacle(cell_011);
            const float obstacle_111 = get_obstacle(cell_111);

            const float4 temperature_000 = color_temperature_texture[cell_000] * obstacle_000;
            const float4 temperature_100 = color_temperature_texture[cell_100] * obstacle_100;
            const float4 temperature_010 = color_temperature_texture[cell_010] * obstacle_010;
            const float4 temperature_001 = color_temperature_texture[cell_001] * obstacle_001;
            const float4 temperature_110 = color_temperature_texture[cell_110] * obstacle_110;
            const float4 temperature_101 = color_temperature_texture[cell_101] * obstacle_101;
            const float4 temperature_011 = color_temperature_texture[cell_011] * obstacle_011;
            const float4 temperature_111 = color_temperature_texture[cell_111] * obstacle_111;

            const float x_1 = previous_uv.x - cell_000.x;
            const float x_0 = 1.0f - x_1;

            const float y_1 = previous_uv.y - cell_000.y;
            const float y_0 = 1.0f - y_1;

            const float z_1 = previous_uv.z - cell_000.z;
            const float z_0 = 1.0f - z_1;

            const float inf_000 = x_0 * y_0 * z_0;
            const float inf_100 = x_1 * y_0 * z_0;
            const float inf_010 = x_0 * y_1 * z_0;
            const float inf_001 = x_0 * y_0 * z_1;
            const float inf_110 = x_1 * y_1 * z_0;
            const float inf_101 = x_1 * y_0 * z_1;
            const float inf_011 = x_0 * y_1 * z_1;
            const float inf_111 = x_1 * y_1 * z_1;
            
            float4 temperature
                = temperature_000 * inf_000
                    + temperature_100 * inf_100
                        + temperature_010 * inf_010
                            + temperature_001 * inf_001
                                + temperature_110 * inf_110
                                    + temperature_101 * inf_101
                                        + temperature_011 * inf_011
                                            + temperature_111 * inf_111;
            
            color_temperature_texture[pixel_id] = temperature;
        }
    }
}

[numthreads(8,8,8)]
void kernel_diffusion_temperature (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;

    const float obstacle = get_obstacle(pixel_id);
    if (obstacle)
    {
        const int3 top_pixel_id    = pixel_id + TOP_OFFSET;
        const int3 bottom_pixel_id = pixel_id + BOTTOM_OFFSET;
        const int3 right_pixel_id  = pixel_id + RIGHT_OFFSET;
        const int3 left_pixel_id   = pixel_id + LEFT_OFFSET;
        const int3 front_pixel_id  = pixel_id + FRONT_OFFSET;
        const int3 back_pixel_id   = pixel_id + BACK_OFFSET;
        
        const float top_obstacle    = get_obstacle(top_pixel_id);
        const float bottom_obstacle = get_obstacle(bottom_pixel_id);
        const float right_obstacle  = get_obstacle(right_pixel_id);
        const float left_obstacle   = get_obstacle(left_pixel_id);
        const float front_obstacle  = get_obstacle(front_pixel_id);
        const float back_obstacle   = get_obstacle(back_pixel_id);

        const float4 temperature_value        = color_temperature_texture[pixel_id];
        const float4 top_temperature_value    = color_temperature_texture[top_pixel_id]    * top_obstacle;
        const float4 bottom_temperature_value = color_temperature_texture[bottom_pixel_id] * bottom_obstacle;
        const float4 right_temperature_value  = color_temperature_texture[right_pixel_id]  * right_obstacle;
        const float4 left_temperature_value   = color_temperature_texture[left_pixel_id]   * left_obstacle; 
        const float4 front_temperature_value  = color_temperature_texture[front_pixel_id]  * front_obstacle;
        const float4 back_temperature_value   = color_temperature_texture[back_pixel_id]   * back_obstacle; 

        const float resolution = (texture_resolution.x + texture_resolution.y + texture_resolution.z) / 3.0f;
        const float k = delta_time * diffusion_intensity;
        
        //const float k = delta_time * diffusion_intensity;
        
        const float4 temperature =
        (
            temperature_value
            + k
            * (top_temperature_value + bottom_temperature_value + right_temperature_value + left_temperature_value + front_temperature_value + back_temperature_value)
        )
        / (1 + 6.0 * k);
    
        color_temperature_texture[pixel_id] = temperature;
    }
}

[numthreads(8,8,8)]
void kernel_simulate_wind (uint3 id : SV_DispatchThreadID)
{
    const int3 pixel_id = id.xyz;
    
    float3 velocity = wind_direction * wind_intensity;
    // add fire lifting force
    if (velocity.y < 0.001f)
    {
        velocity.y = 0.001f;
    } 
    velocity_texture[pixel_id] = velocity;
}